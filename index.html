<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SlouchDetectorV0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2a2a2a;
            color: #ddd;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .container {
            width: calc(100vw - 20px);
            height: calc(100vh - 20px);
            max-width: none;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-container {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: box-shadow 0.3s ease;
        }

        /* Orange glow when tracking is active */
        .video-container.tracking-active {
            box-shadow: 0 0 0 2px #ff8c00, 0 0 20px rgba(255, 140, 0, 0.6);
        }

        #video {
            display: block;
            border-radius: 15px;
            transform: scaleX(-1);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Title overlays */
        .title-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .title-main {
            color: white;
            font-size: clamp(1.2em, 4vw, 2em);
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            -webkit-text-stroke: 1px black;
            text-stroke: 1px black;
            margin: 0;
        }

        .version-overlay {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .title-version {
            color: white;
            font-size: clamp(0.8em, 3vw, 1.2em);
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            -webkit-text-stroke: 1px black;
            text-stroke: 1px black;
            margin: 0;
        }

        /* Workflow Steps - Bottom Left */
        .workflow-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 10;
            pointer-events: auto;
            max-width: min(300px, 40vw);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .workflow-step {
            display: none;
        }

        .workflow-step.active {
            display: block;
        }

        .step-title {
            color: white;
            font-size: clamp(0.8em, 2.5vw, 1em);
            margin-bottom: 8px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            -webkit-text-stroke: 0.5px black;
            text-stroke: 0.5px black;
        }

        .step-instruction {
            font-size: clamp(0.6em, 2vw, 0.8em);
            margin-bottom: 10px;
            line-height: 1.3;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            -webkit-text-stroke: 0.5px black;
            text-stroke: 0.5px black;
        }

        /* Monitoring Controls - Bottom Right */
        .monitoring-overlay {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 10;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Next Button - Bottom Center */
        .next-button-overlay {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Calibration Complete - Bottom Center */
        .calibration-complete-overlay {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show overlays when camera is ready */
        .overlays-ready .title-overlay,
        .overlays-ready .version-overlay,
        .overlays-ready .workflow-overlay,
        .overlays-ready .monitoring-overlay,
        .overlays-ready .next-button-overlay,
        .overlays-ready .calibration-complete-overlay {
            opacity: 1;
        }

        /* Buttons */
        .btn {
            background: rgba(68, 68, 68, 0.8);
            border: 1px solid #555;
            color: #ddd;
            padding: clamp(12px, 3vw, 18px) clamp(24px, 6vw, 36px);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: clamp(14px, 3.5vw, 18px);
            transition: all 0.3s ease;
            margin: 0 6px;
            backdrop-filter: blur(5px);
            min-height: clamp(44px, 8vw, 60px);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            white-space: nowrap;
        }

        .btn:hover {
            background: rgba(85, 85, 85, 0.9);
            border-color: #666;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            background: rgba(51, 51, 51, 0.6);
            color: #555;
            cursor: not-allowed;
            border-color: #444;
            transform: none;
            box-shadow: none;
        }

        /* Green glow animation for ready to calibrate */
        .btn.ready-to-calibrate {
            background: rgba(40, 167, 69, 0.8);
            border-color: #28a745;
            color: white;
            animation: greenGlow 2s ease-in-out infinite alternate;
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.6);
        }

        @keyframes greenGlow {
            0% { 
                box-shadow: 0 0 20px rgba(40, 167, 69, 0.6);
                transform: scale(1);
            }
            100% { 
                box-shadow: 0 0 30px rgba(40, 167, 69, 0.8);
                transform: scale(1.02);
            }
        }

        /* Yellow glow animation for calibration in progress */
        .btn.calibrating {
            background: rgba(255, 193, 7, 0.8);
            border-color: #ffc107;
            color: #000;
            animation: yellowGlow 1.5s ease-in-out infinite alternate;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.6);
        }

        @keyframes yellowGlow {
            0% { 
                box-shadow: 0 0 20px rgba(255, 193, 7, 0.6);
                transform: scale(1);
            }
            100% { 
                box-shadow: 0 0 30px rgba(255, 193, 7, 0.8);
                transform: scale(1.02);
            }
        }

        /* Calibration success indicator */
        .calibration-success {
            display: inline-flex;
            align-items: center;
            margin-left: 15px;
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.5s ease;
        }

        .calibration-success.show {
            opacity: 1;
            transform: translateX(0);
        }

        .success-indicator {
            width: clamp(24px, 4vw, 32px);
            height: clamp(24px, 4vw, 32px);
            background: #28a745;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            animation: successPop 0.6s ease-out;
        }

        .success-indicator::after {
            content: "✓";
            color: white;
            font-size: clamp(12px, 2.5vw, 16px);
            font-weight: bold;
        }

        @keyframes successPop {
            0% { 
                transform: scale(0);
                opacity: 0;
            }
            50% { 
                transform: scale(1.2);
            }
            100% { 
                transform: scale(1);
                opacity: 1;
            }
        }

        .success-text {
            color: white;
            font-size: clamp(12px, 2.8vw, 16px);
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            -webkit-text-stroke: 0.5px black;
            text-stroke: 0.5px black;
        }

        .btn-success {
            background: rgba(76, 76, 76, 0.8);
            border-color: #666;
        }

        .btn-success:hover {
            background: rgba(95, 95, 95, 0.9);
        }

        /* Green glow for Track Posture button when ready */
        .btn-success.ready-to-track {
            background: rgba(40, 167, 69, 0.8);
            border-color: #28a745;
            color: white;
            animation: greenGlow 2s ease-in-out infinite alternate;
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.6);
        }

        .btn-danger {
            background: rgba(68, 68, 68, 0.8);
            border-color: #555;
        }

        .btn-danger:hover {
            background: rgba(85, 85, 85, 0.9);
        }

        /* Note: Threshold controls removed - alert delay is now hardcoded to 1 second */

        /* Calibration Status */
        .calibration-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: clamp(0.7em, 2.2vw, 0.9em);
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            -webkit-text-stroke: 0.5px black;
            text-stroke: 0.5px black;
        }

        .checkmark {
            color: white;
            font-size: 1em;
            font-weight: bold;
        }

        /* Loading indicator */
        .loading {
            color: white;
            font-style: italic;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            -webkit-text-stroke: 0.5px black;
            text-stroke: 0.5px black;
        }

        /* Alert Message */
        .alert-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(244, 67, 54, 0.95);
            color: white;
            padding: 25px 50px;
            border-radius: 15px;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            display: none;
            animation: alertPulse 0.5s infinite alternate;
        }

        @keyframes alertPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.05); }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            .container {
                width: calc(100vw - 10px);
                height: calc(100vh - 10px);
            }

            .workflow-overlay {
                max-width: 50vw;
            }

            .btn {
                touch-action: manipulation;
                min-height: clamp(40px, 10vw, 50px);
                padding: clamp(10px, 4vw, 16px) clamp(20px, 8vw, 32px);
                font-size: clamp(12px, 4vw, 16px);
            }

            .calibration-success {
                margin-left: 10px;
            }

            .success-indicator {
                width: clamp(20px, 5vw, 28px);
                height: clamp(20px, 5vw, 28px);
            }

            .success-text {
                font-size: clamp(10px, 3.5vw, 14px);
            }
        }

        @media (max-width: 480px) {
            .workflow-overlay {
                max-width: 60vw;
            }

            .btn {
                margin: 0 3px;
                padding: clamp(8px, 5vw, 14px) clamp(16px, 10vw, 28px);
            }

            .calibration-success {
                margin-left: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-container">
            <video id="video" autoplay muted></video>
            <canvas class="overlay" id="overlay"></canvas>
            
            <!-- Title Overlay - Top Left -->
            <div class="title-overlay">
                <h1 class="title-main">SlouchDetector</h1>
            </div>
            
            <!-- Version Overlay - Top Right -->
            <div class="version-overlay">
                <div class="title-version">V0</div>
            </div>
            
            <!-- Workflow Steps - Bottom Left -->
            <div class="workflow-overlay">
                <!-- Step 1: Start Calibration -->
                <div class="workflow-step active" id="step1">
                    <div class="step-instruction">
                        <span id="loadingStatus" class="loading">Starting camera and loading face detection...</span>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <button class="btn" id="startCalibrationBtn" disabled>Calibrate Posture</button>
                        <div class="calibration-success" id="calibrationSuccess">
                            <div class="success-indicator"></div>
                            <span class="success-text">Calibrated</span>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Set Posture -->
                <div class="workflow-step" id="step2">
                    <div class="step-title">Set Good Posture</div>
                    <div class="step-instruction">
                        Take the posture you wish to maintain and click Next
                    </div>
                </div>

                <!-- Step 3: Set Thresholds -->
                <div class="workflow-step" id="step3">
                    <div class="step-title">Configure Alerts</div>
                    <div class="step-instruction">
                        Alert delay is set to 1 second. Click Done to complete setup.
                    </div>
                    
                    <button class="btn" id="doneBtn">Done</button>
                </div>
            </div>
            
            <!-- Next Button - Bottom Center (only for step 2) -->
            <div class="next-button-overlay" id="nextButtonOverlay" style="display: none;">
                <button class="btn" id="nextBtn" disabled>Next</button>
            </div>
            
            <!-- Calibration Complete - Bottom Center -->
            <div class="calibration-complete-overlay" id="calibrationComplete" style="display: none;">
                <div class="calibration-status">
                    <span class="checkmark">✓</span>
                    <span>Calibration Complete</span>
                </div>
            </div>
            
            <!-- Monitoring Controls - Bottom Right -->
            <div class="monitoring-overlay" id="monitoringControls" style="display: none;">
                <button class="btn btn-success" id="startMonitoringBtn">Track Posture</button>
                <button class="btn btn-danger" id="pauseMonitoringBtn" style="display: none;">Stop Tracking</button>
            </div>
        </div>
    </div>

    <div class="alert-message" id="alertMessage">
        POSTURE ALERT!<br>
        Sit up straight!
    </div>

    <!-- MediaPipe Face Landmarker - Correct ES6 Module Import -->
    <script type="module">
        import { FilesetResolver, FaceLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js';
        
        // Initialize MediaPipe when page loads
        async function initializeApp() {
            try {
                console.log("Loading face detection system...");
                
                // Show loading status
                document.getElementById('loadingStatus').style.display = 'inline';
                
                // Create the app instance and initialize
                const app = new SlouchDetectorV0();
                await app.initializeMediaPipe(FilesetResolver, FaceLandmarker);
                
                // Start camera automatically
                try {
                    await app.startCamera();
                    
                    // Update UI to show ready state
                    document.getElementById('loadingStatus').style.display = 'none';
                    document.getElementById('startCalibrationBtn').disabled = false;
                    
                    // Add green glow to indicate ready to calibrate
                    document.getElementById('startCalibrationBtn').classList.add('ready-to-calibrate');
                    
                } catch (cameraError) {
                    console.error("❌ Failed to start camera:", cameraError);
                    // The handleCameraError method will be called from startCamera() and will update the UI
                    // Overlays will remain hidden if camera fails
                }
                
                // Store app instance globally for access from other scripts
                window.slouchDetector = app;
                
                            } catch (error) {
                    console.error("❌ Failed to initialize face detection:", error);
                    document.getElementById('loadingStatus').textContent = 'Failed to load face detection. Please refresh the page.';
                }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
    
    <script>
        class SlouchDetectorV0 {
            constructor() {
                this.video = document.getElementById('video');
                this.overlay = document.getElementById('overlay');
                this.ctx = this.overlay.getContext('2d');
                
                this.currentStep = 1;
                this.isMonitoring = false;
                this.isCalibrated = false;
                this.showLandmarks = false;
                
                // Calibration state tracking
                this.calibrationState = 'ready'; // 'ready', 'capturing', 'completed'
                
                // Scaling factors for coordinate conversion
                this.scaleX = 1;
                this.scaleY = 1;
                
                // Face detection system
                this.faceLandmarker = null;
                this.isModelLoaded = false;
                this.detectionStarted = false;
                this.detectionInterval = null;
                this.isDetectionRunning = false;
                
                // Baseline values
                this.baseline = {
                    leftEye: null,
                    rightEye: null,
                    leftEar: null,
                    rightEar: null
                };
                
                // Current detection values
                this.current = {
                    leftEye: null,
                    rightEye: null,
                    leftEar: null,
                    rightEar: null
                };
                
                // Settings
                this.verticalThreshold = 0;
                this.alertDelay = 1000; // Hardcoded to 1 second
                this.alertTimer = null;
                this.audioContext = null;
                
                this.initializeElements();
                this.setupEventListeners();
            }

            async initializeMediaPipe(FilesetResolver, FaceLandmarker) {
                try {
                    console.log("Initializing face detection system...");
                    
                    // Initialize face detection WASM
                    const vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
                    );
                    
                    console.log("Creating face detection model...");
                    this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                            delegate: "GPU"
                        },
                        outputFaceBlendshapes: false,
                        outputFacialTransformationMatrixes: false,
                        runningMode: "VIDEO",
                        numFaces: 1,
                        minFaceDetectionConfidence: 0.5,
                        minFacePresenceConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    this.isModelLoaded = true;
                    console.log("✅ Face detection system ready");
                } catch (error) {
                    console.error("❌ Error creating face detection system:", error);
                    throw error;
                }
            }

            initializeElements() {
                // Buttons
                this.startCalibrationBtn = document.getElementById('startCalibrationBtn');
                this.nextBtn = document.getElementById('nextBtn');
                this.doneBtn = document.getElementById('doneBtn');
                this.startMonitoringBtn = document.getElementById('startMonitoringBtn');
                this.pauseMonitoringBtn = document.getElementById('pauseMonitoringBtn');
                
                // Steps
                this.step1 = document.getElementById('step1');
                this.step2 = document.getElementById('step2');
                this.step3 = document.getElementById('step3');
                
                // Displays
                this.calibrationComplete = document.getElementById('calibrationComplete');
                this.monitoringControls = document.getElementById('monitoringControls');
                this.nextButtonOverlay = document.getElementById('nextButtonOverlay');
                this.calibrationSuccess = document.getElementById('calibrationSuccess');
                this.videoContainer = this.video.parentElement;
                
                // Note: Alert delay is now hardcoded to 1 second
                
                this.alertMessage = document.getElementById('alertMessage');
            }

            setupEventListeners() {
                this.startCalibrationBtn.addEventListener('click', () => this.startCalibration());
                this.nextBtn.addEventListener('click', () => this.nextStep());
                this.doneBtn.addEventListener('click', () => this.completeCalibration());
                this.startMonitoringBtn.addEventListener('click', () => this.startMonitoring());
                this.pauseMonitoringBtn.addEventListener('click', () => this.pauseMonitoring());

                this.video.addEventListener('loadedmetadata', () => {
                    console.log('Video metadata loaded:', this.video.videoWidth, 'x', this.video.videoHeight);
                    this.updateVideoContainerSize();
                });

                // Update video container size when window is resized
                window.addEventListener('resize', () => {
                    this.updateVideoContainerSize();
                });
                
                this.video.addEventListener('playing', () => {
                    console.log('Video started playing');
                    // Start detection when video is playing and model is ready
                    if (this.isModelLoaded && !this.detectionStarted) {
                        this.detectionStarted = true;
                        this.startFaceDetection();
                    }
                });
            }

            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1920, min: 1280 },
                            height: { ideal: 1080, min: 720 },
                            frameRate: { ideal: 30, min: 24 },
                            facingMode: 'user',
                            aspectRatio: { ideal: 16/9 }
                        },
                        audio: false
                    });
                    
                    this.video.srcObject = stream;
                    this.initializeAudio();
                    
                    // Wait for video to be ready
                    await new Promise((resolve) => {
                        this.video.addEventListener('loadedmetadata', resolve, { once: true });
                    });
                    
                    // Ensure video container is properly sized
                    this.updateVideoContainerSize();
                    
                    console.log('Camera started successfully');
                    
                } catch (error) {
                    console.error('Error starting camera:', error);
                    this.hideOverlays(); // Keep overlays hidden if camera fails
                    this.handleCameraError(error);
                    throw error;
                }
            }

            handleCameraError(error) {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                
                let message = 'Camera access is required for posture detection.\n\n';
                
                if (error.name === 'NotAllowedError') {
                    if (isMobile) {
                        if (isIOS) {
                            message += 'On iPhone/iPad:\n';
                            message += '1. Go to Settings > Safari > Camera\n';
                            message += '2. Select "Allow" or "Ask"\n';
                            message += '3. Refresh this page and allow camera access\n\n';
                            message += 'Or try opening this page in Safari instead of Chrome.';
                        } else {
                            message += 'On Android:\n';
                            message += '1. Tap the camera icon in the address bar\n';
                            message += '2. Select "Allow"\n';
                            message += '3. Refresh this page';
                        }
                    } else {
                        message += 'Please:\n';
                        message += '1. Click the camera icon in your browser\'s address bar\n';
                        message += '2. Select "Allow"\n';
                        message += '3. Refresh this page';
                    }
                } else if (error.name === 'NotFoundError') {
                    message += 'No camera found on this device.\n';
                    message += 'Please make sure your device has a working camera.';
                } else if (error.name === 'NotReadableError') {
                    message += 'Camera is being used by another application.\n';
                    message += 'Please close other apps using the camera and try again.';
                } else {
                    message += 'Unable to access camera.\n';
                    message += 'Please check your camera permissions and try again.';
                }
                
                alert(message);
                
                // Show a retry option in the UI
                this.showRetryOption();
            }

            showRetryOption() {
                const loadingStatus = document.getElementById('loadingStatus');
                loadingStatus.innerHTML = `
                    <div style="margin-bottom: 10px;">Camera access denied.</div>
                    <button class="btn" onclick="window.slouchDetector.retryCamera()" style="font-size: clamp(12px, 3vw, 16px); padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 24px);">
                        Request Camera Access
                    </button>
                `;
            }

            async retryCamera() {
                const loadingStatus = document.getElementById('loadingStatus');
                loadingStatus.innerHTML = '<span class="loading">Requesting camera access...</span>';
                
                try {
                    await this.startCamera();
                    
                    // Success! Update UI
                    document.getElementById('loadingStatus').style.display = 'none';
                    document.getElementById('startCalibrationBtn').disabled = false;
                    document.getElementById('startCalibrationBtn').classList.add('ready-to-calibrate');
                    
                } catch (error) {
                    // Error handled by startCamera's catch block
                    console.log('Retry failed:', error.message);
                }
            }

            async startCalibration() {
                if (!this.isModelLoaded) {
                    alert('Face detection is not ready yet. Please wait a moment and try again.');
                    return;
                }

                if (this.calibrationState === 'ready') {
                    // First click: Start capturing posture
                    this.calibrationState = 'capturing';
                    this.showLandmarks = true;
                    
                    // Update button appearance
                    this.startCalibrationBtn.textContent = 'Save Posture';
                    this.startCalibrationBtn.classList.remove('ready-to-calibrate');
                    this.startCalibrationBtn.classList.add('calibrating');
                    
                    // Hide success indicator if it was showing
                    this.calibrationSuccess.classList.remove('show');
                    
                    console.log('Calibration started - waiting for user to click Save Posture');
                    
                } else if (this.calibrationState === 'capturing') {
                    // Second click: Save the current posture as baseline
                    if (!this.current.leftEye || !this.current.rightEye) {
                        alert('No face detected. Please ensure your face is visible and try again.');
                        return;
                    }
                    
                    this.calibrationState = 'completed';
                    
                    // Capture baseline values
                    this.baseline = { ...this.current };
                    this.isCalibrated = true;
                    
                    // Update button appearance
                    this.startCalibrationBtn.textContent = 'Calibrate Posture';
                    this.startCalibrationBtn.classList.remove('calibrating');
                    
                    // Show success indicator
                    this.calibrationSuccess.classList.add('show');
                    
                    // Show monitoring controls
                    this.showMonitoringInterface();
                    
                    console.log('Posture baseline captured:', this.baseline);
                    
                } else if (this.calibrationState === 'completed') {
                    // Third click: Reset and start over
                    this.resetCalibration();
                    
                    // Start the process again
                    setTimeout(() => {
                        this.startCalibration();
                    }, 100);
                }
            }

            resetCalibration() {
                console.log('Resetting calibration');
                
                // Reset state
                this.calibrationState = 'ready';
                this.isCalibrated = false;
                this.isMonitoring = false;
                this.showLandmarks = false;
                
                // Reset baseline values
                this.baseline = {
                    leftEye: null,
                    rightEye: null,
                    leftEar: null,
                    rightEar: null
                };
                
                // Reset button appearance
                this.startCalibrationBtn.textContent = 'Calibrate Posture';
                this.startCalibrationBtn.classList.remove('calibrating');
                this.startCalibrationBtn.classList.add('ready-to-calibrate');
                
                // Hide success indicator
                this.calibrationSuccess.classList.remove('show');
                
                // Hide monitoring interface
                this.hideMonitoringInterface();
                
                // Clear any alerts
                this.clearAlert();
                
                // Clear canvas
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.overlay.width, this.overlay.height);
                }
            }

            showMonitoringInterface() {
                // Show the monitoring controls
                this.monitoringControls.style.display = 'block';
                this.startMonitoringBtn.style.display = 'inline-block';
                this.pauseMonitoringBtn.style.display = 'none';
                
                // Add green glow to indicate ready to track
                this.startMonitoringBtn.classList.add('ready-to-track');
            }

            hideMonitoringInterface() {
                // Hide the monitoring controls
                this.monitoringControls.style.display = 'none';
                
                // Remove green glow when hiding monitoring interface
                this.startMonitoringBtn.classList.remove('ready-to-track');
                
                // Remove orange glow when hiding monitoring
                if (this.videoContainer) {
                    this.videoContainer.classList.remove('tracking-active');
                }
            }

            updateVideoContainerSize() {
                if (this.video && this.video.videoWidth && this.video.videoHeight) {
                    const containerWidth = window.innerWidth - 20; // Account for 10px padding on each side
                    const containerHeight = window.innerHeight - 20;
                    
                    const videoAspectRatio = this.video.videoWidth / this.video.videoHeight;
                    const containerAspectRatio = containerWidth / containerHeight;
                    
                    let displayWidth, displayHeight;
                    
                    if (videoAspectRatio > containerAspectRatio) {
                        // Video is wider than container, fit by width
                        displayWidth = containerWidth;
                        displayHeight = containerWidth / videoAspectRatio;
                    } else {
                        // Video is taller than container, fit by height
                        displayHeight = containerHeight;
                        displayWidth = containerHeight * videoAspectRatio;
                    }
                    
                    // Set video size to exact calculated dimensions
                    this.video.style.width = displayWidth + 'px';
                    this.video.style.height = displayHeight + 'px';
                    
                    // Set container size to match video exactly (no black bars)
                    this.video.parentElement.style.width = displayWidth + 'px';
                    this.video.parentElement.style.height = displayHeight + 'px';
                    
                    console.log(`Video container sized: ${displayWidth}x${displayHeight}, Aspect ratio: ${videoAspectRatio.toFixed(3)}`);
                    
                    // Update canvas after container is resized
                    this.updateCanvasSize();
                    
                    // Show overlays now that video container is properly sized
                    this.showOverlays();
                }
            }

            updateCanvasSize() {
                if (this.video && this.overlay && this.video.videoWidth && this.video.videoHeight) {
                    // Canvas should match the video element's size exactly
                    const videoRect = this.video.getBoundingClientRect();
                    const displayWidth = videoRect.width;
                    const displayHeight = videoRect.height;
                    
                    // Set canvas size to match the video size
                    this.overlay.width = displayWidth;
                    this.overlay.height = displayHeight;
                    
                    // Store the scaling factors for coordinate conversion
                    this.scaleX = displayWidth / this.video.videoWidth;
                    this.scaleY = displayHeight / this.video.videoHeight;
                    
                    console.log(`Canvas updated: ${displayWidth}x${displayHeight}, Scale: ${this.scaleX.toFixed(3)}x${this.scaleY.toFixed(3)}`);
                }
            }

            showOverlays() {
                // Add class to show overlays with smooth transition
                if (this.video && this.video.parentElement) {
                    this.video.parentElement.classList.add('overlays-ready');
                    console.log('Overlays are now visible');
                }
            }

            hideOverlays() {
                // Remove class to hide overlays
                if (this.video && this.video.parentElement) {
                    this.video.parentElement.classList.remove('overlays-ready');
                    console.log('Overlays are now hidden');
                }
            }

            startFaceDetection() {
                if (!this.isModelLoaded || !this.faceLandmarker) {
                    console.error("Cannot start face detection - system not ready");
                    return;
                }

                console.log("Starting real-time face detection");
                let lastVideoTime = -1;
                this.detectionInterval = null;
                this.isDetectionRunning = true;
                
                const detectFace = () => {
                    if (!this.isDetectionRunning) return;
                    
                    if (this.video.currentTime !== lastVideoTime && this.video.videoWidth > 0 && this.video.videoHeight > 0) {
                        try {
                            const results = this.faceLandmarker.detectForVideo(this.video, performance.now());
                            this.processFaceResults(results);
                            lastVideoTime = this.video.currentTime;
                        } catch (error) {
                            console.error("Face detection error:", error);
                        }
                    }
                    
                    // Use requestAnimationFrame when tab is visible, setInterval when hidden
                    if (document.visibilityState === 'visible') {
                        if (this.detectionInterval) {
                            clearInterval(this.detectionInterval);
                            this.detectionInterval = null;
                        }
                        requestAnimationFrame(detectFace);
                    } else {
                        // When tab is hidden, use setInterval to keep detection running
                        if (!this.detectionInterval) {
                            this.detectionInterval = setInterval(detectFace, 33); // ~30 FPS
                        }
                    }
                };
                
                // Listen for visibility changes to switch between RAF and setInterval
                document.addEventListener('visibilitychange', () => {
                    if (this.isDetectionRunning) {
                        if (document.visibilityState === 'visible') {
                            console.log('Tab became visible - switching to requestAnimationFrame');
                            if (this.detectionInterval) {
                                clearInterval(this.detectionInterval);
                                this.detectionInterval = null;
                            }
                            requestAnimationFrame(detectFace);
                        } else {
                            console.log('Tab became hidden - switching to setInterval for background detection');
                            if (!this.detectionInterval) {
                                this.detectionInterval = setInterval(detectFace, 33); // ~30 FPS
                            }
                        }
                    }
                });
                
                detectFace();
            }

            processFaceResults(results) {
                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];
                    
                    // Face landmark indices:
                    // Left eye center: landmarks 33 (outer) + 133 (inner) averaged
                    // Right eye center: landmarks 362 (inner) + 263 (outer) averaged  
                    // Left ear: Use face outline landmark 172 (left face boundary)
                    // Right ear: Use face outline landmark 397 (right face boundary)
                    
                    // Get video dimensions
                    const videoWidth = this.video.videoWidth;
                    const videoHeight = this.video.videoHeight;
                    
                    // Calculate eye centers more accurately
                    const leftEyeInner = landmarks[133]; // Left eye inner corner
                    const leftEyeOuter = landmarks[33];  // Left eye outer corner  
                    const rightEyeInner = landmarks[362]; // Right eye inner corner
                    const rightEyeOuter = landmarks[263]; // Right eye outer corner
                    
                                    // Calculate eye centers with both X and Y coordinates
                const leftEyeCenterX = ((leftEyeInner.x + leftEyeOuter.x) / 2);
                const leftEyeCenterY = ((leftEyeInner.y + leftEyeOuter.y) / 2);
                const rightEyeCenterX = ((rightEyeInner.x + rightEyeOuter.x) / 2);
                const rightEyeCenterY = ((rightEyeInner.y + rightEyeOuter.y) / 2);
                
                // Get ear positions (using top of ear landmarks)
                const leftEarX = landmarks[127] ? landmarks[127].x : leftEyeCenterX - 0.1;
                const leftEarY = landmarks[127] ? landmarks[127].y : leftEyeCenterY + 0.02;
                const rightEarX = landmarks[356] ? landmarks[356].x : rightEyeCenterX + 0.1;
                const rightEarY = landmarks[356] ? landmarks[356].y : rightEyeCenterY + 0.02;
                
                // Convert normalized coordinates (0-1) to displayed pixel coordinates
                const displayWidth = this.overlay.width;
                const displayHeight = this.overlay.height;
                
                this.current = {
                    leftEye: {
                        x: Math.round(leftEyeCenterX * displayWidth),
                        y: Math.round(leftEyeCenterY * displayHeight)
                    },
                    rightEye: {
                        x: Math.round(rightEyeCenterX * displayWidth),
                        y: Math.round(rightEyeCenterY * displayHeight)
                    },
                    leftEar: {
                        x: Math.round(leftEarX * displayWidth),
                        y: Math.round(leftEarY * displayHeight)
                    },
                    rightEar: {
                        x: Math.round(rightEarX * displayWidth),
                        y: Math.round(rightEarY * displayHeight)
                    }
                };
                    
                    // Debug logging to see actual values
                    if (this.step2.classList.contains('active') && this.showLandmarks) {
                        console.log("Face detected - Eye/Ear positions:", this.current);
                        console.log("Display dimensions:", displayWidth, "x", displayHeight);
                        console.log("Video source dimensions:", videoWidth, "x", videoHeight);
                    }
                } else {
                    // No face detected - set to null
                    this.current = {
                        leftEye: null,
                        rightEye: null,
                        leftEar: null,
                        rightEar: null
                    };
                    
                    if (this.step2.classList.contains('active') && this.showLandmarks) {
                        console.log("No face detected");
                    }
                }
                
                this.updateDisplay();
                
                if (this.isMonitoring && this.isCalibrated) {
                    this.checkPosture();
                }
            }

            nextStep() {
                // Capture baseline values
                this.baseline = { ...this.current };
                this.goToStep(3);
            }

            completeCalibration() {
                this.isCalibrated = true;
                this.goToStep(4); // Complete state
            }

            goToStep(step) {
                // Hide all steps
                this.step1.classList.remove('active');
                this.step2.classList.remove('active');
                this.step3.classList.remove('active');
                
                if (step === 2) {
                    this.step2.classList.add('active');
                    this.nextButtonOverlay.style.display = 'block'; // Show next button for step 2
                } else if (step === 3) {
                    this.step3.classList.add('active');
                    this.nextButtonOverlay.style.display = 'none'; // Hide next button for step 3
                } else if (step === 4) {
                    // Show completion state
                    this.calibrationComplete.style.display = 'block';
                    this.monitoringControls.style.display = 'block';
                    this.nextButtonOverlay.style.display = 'none'; // Hide next button for complete state
                }
            }

            startMonitoring() {
                this.isMonitoring = true;
                this.startMonitoringBtn.style.display = 'none';
                this.pauseMonitoringBtn.style.display = 'inline-block';
                
                // Remove green glow since tracking is now active
                this.startMonitoringBtn.classList.remove('ready-to-track');
                
                // Add orange glow to indicate tracking is active
                if (this.videoContainer) {
                    this.videoContainer.classList.add('tracking-active');
                }
            }

            pauseMonitoring() {
                this.isMonitoring = false;
                this.startMonitoringBtn.style.display = 'inline-block';
                this.pauseMonitoringBtn.style.display = 'none';
                this.clearAlert();
                
                // Add green glow back since ready to track again
                this.startMonitoringBtn.classList.add('ready-to-track');
                
                // Remove orange glow when tracking stops
                if (this.videoContainer) {
                    this.videoContainer.classList.remove('tracking-active');
                }
            }

            stopDetection() {
                this.isDetectionRunning = false;
                if (this.detectionInterval) {
                    clearInterval(this.detectionInterval);
                    this.detectionInterval = null;
                }
                console.log('Face detection stopped');
            }

            updateDisplay() {
                this.drawIndicators();
            }

            checkPosture() {
                // Check if we have valid current and baseline data
                if (!this.current.leftEye || !this.current.rightEye || 
                    !this.baseline.leftEye || !this.baseline.rightEye) {
                    return;
                }
                
                const eyeDrop = Math.max(
                    this.current.leftEye.y - this.baseline.leftEye.y,
                    this.current.rightEye.y - this.baseline.rightEye.y
                );
                
                const earDrop = Math.max(
                    this.current.leftEar ? this.current.leftEar.y - this.baseline.leftEar.y : 0,
                    this.current.rightEar ? this.current.rightEar.y - this.baseline.rightEar.y : 0
                );
                
                const maxDrop = Math.max(eyeDrop, earDrop);
                
                if (maxDrop > this.verticalThreshold) {
                    if (!this.alertTimer) {
                        this.alertTimer = setTimeout(() => {
                            this.triggerAlert();
                        }, this.alertDelay);
                    }
                } else {
                    this.clearAlert();
                }
            }

            drawIndicators() {
                if (!this.overlay.width || !this.overlay.height) return;
                
                this.ctx.clearRect(0, 0, this.overlay.width, this.overlay.height);
                
                // Only draw landmarks if calibration has started
                if (!this.showLandmarks) return;
                
                /* LANDMARK DRAWING - COMMENTED OUT (uncomment to show visual indicators)
                // Only draw if we have valid detection values
                if (this.current.leftEye !== null && this.current.rightEye !== null) {
                    // Draw current eye positions
                    this.drawLandmark(this.current.leftEye, '#888', 'Left Eye', false);
                    this.drawLandmark(this.current.rightEye, '#888', 'Right Eye', false);
                    
                    // Draw current ear positions if available
                    if (this.current.leftEar !== null && this.current.rightEar !== null) {
                        this.drawLandmark(this.current.leftEar, '#666', 'Left Ear', false);
                        this.drawLandmark(this.current.rightEar, '#666', 'Right Ear', false);
                    }
                }
                
                // Draw baseline positions if calibrated
                if (this.baseline.leftEye !== null && this.baseline.rightEye !== null) {
                    this.drawLandmark(this.baseline.leftEye, '#aaa', 'Baseline Left Eye', true);
                    this.drawLandmark(this.baseline.rightEye, '#aaa', 'Baseline Right Eye', true);
                    
                    if (this.baseline.leftEar !== null && this.baseline.rightEar !== null) {
                        this.drawLandmark(this.baseline.leftEar, '#999', 'Baseline Left Ear', true);
                        this.drawLandmark(this.baseline.rightEar, '#999', 'Baseline Right Ear', true);
                    }
                }
                */
            }

            drawLandmark(point, color, label, isDashed) {
                if (!point || point.x === null || point.y === null) return;
                
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
                this.ctx.lineWidth = 2;
                
                // Set line style for baseline vs current
                if (isDashed) {
                    this.ctx.setLineDash([5, 5]);
                } else {
                    this.ctx.setLineDash([]);
                }
                
                // Draw horizontal reference line extending from the landmark
                // Determine direction based on whether it's a left or right landmark
                this.ctx.beginPath();
                if (label.includes('Left')) {
                    // Left landmarks extend to the left edge
                    this.ctx.moveTo(0, point.y);
                    this.ctx.lineTo(point.x, point.y);
                } else if (label.includes('Right')) {
                    // Right landmarks extend to the right edge  
                    this.ctx.moveTo(point.x, point.y);
                    this.ctx.lineTo(this.overlay.width, point.y);
                } else {
                    // Fallback: full width line
                    this.ctx.moveTo(0, point.y);
                    this.ctx.lineTo(this.overlay.width, point.y);
                }
                this.ctx.stroke();
                
                // Draw a circle at the landmark position
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw a small cross for better visibility
                this.ctx.setLineDash([]); // Use solid lines for the cross
                this.ctx.beginPath();
                this.ctx.moveTo(point.x - 8, point.y);
                this.ctx.lineTo(point.x + 8, point.y);
                this.ctx.moveTo(point.x, point.y - 8);
                this.ctx.lineTo(point.x, point.y + 8);
                this.ctx.stroke();

                
                // Reset line dash
                this.ctx.setLineDash([]);
            }

            async initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    console.log('Audio context not available');
                }
            }

            triggerAlert() {
                this.alertMessage.style.display = 'block';
                setTimeout(() => {
                    this.alertMessage.style.display = 'none';
                }, 2000);
                
                this.playAlertSound();
                this.alertTimer = null;
            }

            playAlertSound() {
                if (this.audioContext) {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(1200, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime + 0.2);
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                }
            }

            clearAlert() {
                if (this.alertTimer) {
                    clearTimeout(this.alertTimer);
                    this.alertTimer = null;
                }
                this.alertMessage.style.display = 'none';
            }
        }

        // Note: App initialization is handled in the ES6 module above
    </script>
</body>
</html>
